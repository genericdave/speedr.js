// Generated by CoffeeScript 1.3.1
var speedr,
  __slice = [].slice;

speedr = {};

if (typeof document !== "undefined" && document !== null) {
  speedr.ie = (function(){

	    var v = 3,
	        div = document.createElement('div'),
	        all = div.getElementsByTagName('i');

	    while (
	        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
	        all[0]
	    );

	    return v > 4 ? v : false;

	}());;

} else {
  speedr.ie = false;
}

speedr.getArrays = function(obj) {
  var k, keys, v, vals;
  if (obj !== Object(obj)) {
    throw new Error('No keys for non-object');
  }
  keys = [];
  vals = [];
  for (k in obj) {
    v = obj[k];
    if (hasOwnProperty.call(obj, k)) {
      keys[keys.length] = k;
      vals[vals.length] = v;
    }
  }
  return [keys, vals];
};

speedr.binarySearch = function(arr, val, exactOnly) {
  var h, l, m;
  if (exactOnly == null) {
    exactOnly = false;
  }
  h = arr.length;
  l = -1;
  while (h - l > 1) {
    if (arr[m = (h + l) >> 1] > val) {
      l = m;
    } else {
      h = m;
    }
  }
  if (exactOnly) {
    if (arr[h] === val) {
      return h;
    } else {
      return -1;
    }
  } else {
    return h;
  }
};

speedr.flexiSlice = function(obj, start, end) {
  var i, temp, _i;
  if (toString.call(obj) === '[object Array]') {
    temp = [];
  } else {
    temp = '';
  }
  if (!(end != null)) {
    if (start >= 0) {
      end = obj.length;
    } else {
      end = -obj.length - 1;
    }
  }
  if (end > obj.length) {
    end = obj.length;
  }
  if (end < -obj.length) {
    end = -obj.length - 1;
  }
  if (start > obj.length) {
    start = obj.length - 1;
  }
  if (start < -obj.length) {
    start = -obj.length;
  }
  for (i = _i = start; start <= end ? _i < end : _i > end; i = start <= end ? ++_i : --_i) {
    if (toString.call(obj) === '[object Array]') {
      if (i >= 0) {
        temp.push(obj[i]);
      } else {
        temp.push(obj[obj.length + i]);
      }
    } else {
      if (i >= 0) {
        temp += obj[i];
      } else {
        temp += obj[obj.length + i];
      }
    }
  }
  return temp;
};

speedr.Map = (function() {

  Map.name = 'Map';

  function Map(items) {
    var junk, _ref;
    this.items = items != null ? items : {};
    if (this.items !== Object(this.items)) {
      throw 'Map requires an object for construction.';
    }
    _ref = speedr.getArrays(this.items), this.keys = _ref[0], junk = _ref[1];
    this.updateLength();
  }

  Map.prototype.updateLength = function() {
    this.length = this.keys.length;
    return this.length;
  };

  Map.prototype.get = function(key) {
    return this.items[key];
  };

  Map.prototype.set = function() {
    var i, key, obj, others, pushPair, val, _i, _ref,
      _this = this;
    obj = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    pushPair = function(key, val) {
      if (!(_this.items[key] != null)) {
        _this.keys.push(key);
      }
      return _this.items[key] = val;
    };
    if (others.length === 0) {
      for (key in obj) {
        val = obj[key];
        pushPair(key, val);
      }
    } else {
      pushPair(obj, others[0]);
      for (i = _i = 1, _ref = others.length; _i < _ref; i = _i += 2) {
        pushPair(others[i], others[i + 1]);
      }
    }
    return this.updateLength();
  };

  Map.prototype.remove = function(key) {
    if (this.items[key] != null) {
      delete this.items[key];
      Array.remove(this.keys, key);
    }
    return this.updateLength();
  };

  Map.prototype.each = function(f) {
    var i, k, v, _i, _ref, _ref1;
    if (!speedr.ie) {
      for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        k = this.iterK(i);
        v = this.iterV(i);
        f(k, v);
      }
    } else {
      _ref1 = this.items;
      for (k in _ref1) {
        v = _ref1[k];
        f(k, v);
      }
    }
    return null;
  };

  Map.prototype.eachKey = function(f) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      f(this.iterK(i));
    }
    return null;
  };

  Map.prototype.eachVal = function(f) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      f(this.iterV(i));
    }
    return null;
  };

  Map.prototype.iter = function(counter) {
    return [this.keys[counter], this.items[this.keys[counter]]];
  };

  Map.prototype.iterK = function(counter) {
    return this.keys[counter];
  };

  Map.prototype.iterV = function(counter) {
    return this.items[this.keys[counter]];
  };

  Map.prototype.hasKey = function(key) {
    return this.items[key] != null;
  };

  Map.prototype.hasVal = function(val) {
    var i, result, _i, _ref;
    result = false;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (val === this.iterV(i)) {
        result = true;
        break;
      }
    }
    return result;
  };

  Map.prototype.clear = function() {
    this.items = {};
    this.keys = [];
    this.updateLength();
    return null;
  };

  return Map;

})();

speedr.SortedMap = (function() {

  SortedMap.name = 'SortedMap';

  function SortedMap(items) {
    if (items == null) {
      items = {};
    }
    if (items !== Object(items)) {
      throw 'SortedMap requires an object for construction.';
    }
    this.keys = [];
    this.vals = [];
    this.insert(items);
    this.updateLength();
  }

  SortedMap.prototype.updateLength = function() {
    this.length = this.keys.length;
    return this.length;
  };

  SortedMap.prototype.insert = function(key, val) {
    var i, k, v;
    if (!(key != null)) {
      return this.length;
    }
    if (val != null) {
      i = speedr.binarySearch(this.keys, key);
      this.keys.splice(i, 0, key);
      this.vals.splice(i, 0, val);
      return this.updateLength();
    } else if (key === Object(key)) {
      for (k in key) {
        v = key[k];
        this.insert(k, v);
      }
      return this.updateLength();
    } else {
      throw 'Attempted insert of invalid items.';
    }
  };

  SortedMap.prototype.remove = function(key) {
    var i;
    if (!(key != null)) {
      return this.length;
    }
    i = speedr.binarySearch(this.keys, key);
    this.keys.splice(i, 1);
    this.vals.splice(i, 1);
    return this.updateLength();
  };

  SortedMap.prototype.pop = function() {
    this.keys.pop();
    this.vals.pop();
    return this.updateLength();
  };

  SortedMap.prototype.iter = function(counter) {
    return [this.keys[this.length - 1 - counter], this.vals[this.length - 1 - counter]];
  };

  SortedMap.prototype.iterK = function(counter) {
    return this.keys[this.length - 1 - counter];
  };

  SortedMap.prototype.iterV = function(counter) {
    return this.vals[this.length - 1 - counter];
  };

  SortedMap.prototype.each = function(f) {
    var i, k, v, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      k = this.iterK(i);
      v = this.iterV(i);
      f(k, v);
    }
    return null;
  };

  SortedMap.prototype.eachKey = function(f) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      f(this.iterK(i));
    }
    return null;
  };

  SortedMap.prototype.eachVal = function(f) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      f(this.iterV(i));
    }
    return null;
  };

  SortedMap.prototype.hasKey = function(key) {
    var k, _i, _len, _ref;
    _ref = this.keys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      if (key === k) {
        return true;
      }
    }
    return false;
  };

  SortedMap.prototype.hasVal = function(val) {
    var v, _i, _len, _ref;
    _ref = this.vals;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      if (vals === v) {
        return true;
      }
    }
    return false;
  };

  SortedMap.prototype.clear = function() {
    this.keys = [];
    this.vals = [];
    this.updateLength();
    return null;
  };

  return SortedMap;

})();

speedr.SortedTable = (function() {

  SortedTable.name = 'SortedTable';

  function SortedTable() {
    this.keys = [];
    this.vals = [];
    this.updateLength();
  }

  SortedTable.prototype.updateLength = function() {
    this.length = this.keys.length;
    return this.length;
  };

  SortedTable.prototype.insert = function(key, val) {
    var i;
    i = speedr.binarySearch(this.keys, key);
    this.keys.splice(i, 0, key);
    this.vals.splice(i, 0, val);
    return this.updateLength();
  };

  SortedTable.prototype.remove = function(key, val) {
    var i, j;
    if (!(key != null)) {
      return;
    }
    i = speedr.binarySearch(this.keys, key);
    if (val != null) {
      j = i - 1;
      while (true) {
        if (val === this.vals[i]) {
          break;
        }
        if (val === this.vals[j]) {
          i = j;
          break;
        }
        i++;
        j--;
      }
    }
    this.keys.splice(i, 1);
    this.vals.splice(i, 1);
    return this.updateLength();
  };

  SortedTable.prototype.pop = function() {
    this.keys.pop();
    this.vals.pop();
    return this.updateLength();
  };

  SortedTable.prototype.iter = function(counter) {
    return [this.keys[this.length - 1 - counter], this.vals[this.length - 1 - counter]];
  };

  SortedTable.prototype.iterK = function(counter) {
    return this.keys[this.length - 1 - counter];
  };

  SortedTable.prototype.iterV = function(counter) {
    return this.vals[this.length - 1 - counter];
  };

  return SortedTable;

})();

if ((typeof module !== "undefined" && module !== null) && (typeof exports !== "undefined" && exports !== null)) {
  module.exports = speedr;
} else {
  window.speedr = speedr;
}
